<script>
  import {
    Alert,
    Button,
    EmptyState,
    Group,
    ResizableHandle,
    ResizablePane,
    ResizablePaneGroup,
    Toast,
  } from '@sveltia/ui';
  import { onMount, tick, untrack } from 'svelte';
  import { _ } from 'svelte-i18n';

  import BackupFeedback from '$lib/components/contents/details/backup-feedback.svelte';
  import PaneBody from '$lib/components/contents/details/pane-body.svelte';
  import PaneHeader from '$lib/components/contents/details/pane-header.svelte';
  import Toolbar from '$lib/components/contents/details/toolbar.svelte';
  import { goto } from '$lib/services/app/navigation';
  import { canCreateEntry } from '$lib/services/contents/collection/entries';
  import { entryDraft } from '$lib/services/contents/draft';
  import {
    resetBackupToastState,
    showBackupToastIfNeeded,
  } from '$lib/services/contents/draft/backup';
  import {
    editorFirstPane,
    editorSecondPane,
    showContentOverlay,
    showDuplicateToast,
  } from '$lib/services/contents/editor';
  import { entryEditorSettings } from '$lib/services/contents/editor/settings';
  import { getLocaleLabel } from '$lib/services/contents/i18n';
  import { DEFAULT_I18N_CONFIG } from '$lib/services/contents/i18n/config';
  import { isMediumScreen, isSmallScreen } from '$lib/services/user/env';

  /**
   * @typedef {object} Props
   * @property {string | undefined} [editorLocale] The locale to open the editor in.
   */

  /** @type {Props} */
  let {
    /* eslint-disable prefer-const */
    editorLocale = undefined,
    /* eslint-enable prefer-const */
  } = $props();

  let restoring = false;
  let switching = false;

  let hidden = $state(true);
  /** @type {HTMLElement | undefined} */
  let wrapper = $state();
  /** @type {HTMLElement | undefined} */
  let firstPaneContentArea = $state();
  /** @type {HTMLElement | undefined} */
  let secondPaneContentArea = $state();

  const notFound = $derived($entryDraft === undefined);
  const isNew = $derived($entryDraft?.isNew ?? true);
  const collection = $derived($entryDraft?.collection);
  const entryCollection = $derived(collection?._type === 'entry' ? collection : undefined);
  const collectionFile = $derived($entryDraft?.collectionFile);
  const { showPreview } = $derived($entryEditorSettings ?? {});
  const { i18nEnabled, allLocales, defaultLocale } = $derived(
    (collectionFile ?? collection)?._i18n ?? DEFAULT_I18N_CONFIG,
  );
  const canPreview = $derived($entryDraft?.canPreview ?? true);
  const paneStateKey = $derived(
    collectionFile?.name ? [collection?.name, collectionFile.name].join('|') : collection?.name,
  );
  const canCreate = $derived(entryCollection?.create ?? false);
  const limit = $derived(entryCollection?.limit ?? Infinity);
  const createDisabled = $derived(!canCreateEntry(collection));

  const [firstPaneSize, secondPaneSize, minPaneSize] = $derived.by(() => {
    if (
      typeof $editorFirstPane?.width === 'number' &&
      typeof $editorSecondPane?.width === 'number' &&
      $editorFirstPane.width >= 30 &&
      $editorSecondPane.width >= 30 &&
      $editorFirstPane.width + $editorSecondPane.width === 100
    ) {
      return [$editorFirstPane.width, $editorSecondPane.width, 30];
    }

    if (!$editorFirstPane && !$editorSecondPane) {
      return [0, 0, 0];
    }

    if (!$editorFirstPane || !$editorSecondPane) {
      return [$editorFirstPane ? 100 : 0, $editorSecondPane ? 100 : 0, 0];
    }

    return [50, 50, 30];
  });

  /**
   * Restore the pane state from IndexedDB.
   * @returns {Promise<boolean>} Whether the panes are restored.
   */
  const restorePanes = async () => {
    let [_editorFirstPane, _editorSecondPane] =
      $entryEditorSettings?.paneStates?.[paneStateKey ?? ''] ?? [];

    // Override the locale if specified
    if (editorLocale) {
      _editorFirstPane = { mode: 'edit', locale: editorLocale };
      _editorSecondPane = { mode: 'preview', locale: editorLocale };
    }

    if (
      restoring ||
      !_editorFirstPane ||
      !_editorSecondPane ||
      (!!_editorFirstPane.locale && !allLocales.includes(_editorFirstPane.locale)) ||
      (!!_editorSecondPane.locale && !allLocales.includes(_editorSecondPane.locale)) ||
      ((!showPreview || !canPreview) &&
        (_editorFirstPane.mode === 'preview' || _editorSecondPane.mode === 'preview')) ||
      // If there are only 2 locales and the first pane is not in the default locale, don’t restore
      // the panes so that the default locale is always shown in the first pane
      (allLocales.length === 2 && _editorFirstPane.locale !== defaultLocale)
    ) {
      return false;
    }

    restoring = true;
    await tick();
    $editorFirstPane = _editorFirstPane;
    $editorSecondPane = $isSmallScreen || $isMediumScreen ? null : _editorSecondPane;
    await tick();
    restoring = false;

    return true;
  };

  /**
   * Hide the preview pane if it’s disabled by the user or the collection/file.
   */
  const switchPanes = async () => {
    if (!$entryDraft || switching) {
      return;
    }

    switching = true;

    if (await restorePanes()) {
      switching = false;

      return;
    }

    $editorFirstPane = { mode: 'edit', locale: $editorFirstPane?.locale ?? defaultLocale };

    if ($isSmallScreen || $isMediumScreen) {
      $editorSecondPane = null;
    } else if (!showPreview || !canPreview) {
      const otherLocales = i18nEnabled
        ? allLocales.filter((l) => l !== $editorFirstPane?.locale)
        : [];

      $editorSecondPane = otherLocales.length ? { mode: 'edit', locale: otherLocales[0] } : null;
    } else {
      $editorSecondPane = { mode: 'preview', locale: $editorFirstPane.locale };
    }

    switching = false;
  };

  /**
   * Save the pane state to IndexedDB.
   */
  const savePanes = () => {
    if (!collection || restoring || !$editorFirstPane || !$editorSecondPane || !paneStateKey) {
      return;
    }

    entryEditorSettings.update((view = {}) => ({
      ...view,
      paneStates: {
        ...view.paneStates,
        [paneStateKey]: [$editorFirstPane, $editorSecondPane],
      },
    }));
  };

  /**
   * Move focus to the wrapper once the overlay is loaded.
   */
  const moveFocus = async () => {
    // Wait until `inert` is updated
    await tick();

    if (wrapper) {
      wrapper.tabIndex = 0;
      wrapper.focus();
    }
  };

  onMount(() => () => {
    if (!$showContentOverlay) {
      $entryDraft = null;
    }
  });

  $effect(() => {
    if (paneStateKey) {
      // Reset the editor panes
      $editorFirstPane = null;
      $editorSecondPane = null;
    }
  });

  $effect(() => {
    void [showPreview, canPreview, $isSmallScreen, $isMediumScreen];

    untrack(() => {
      switchPanes();
    });
  });

  $effect(() => {
    void [$editorFirstPane, $editorSecondPane];
    savePanes();
  });

  $effect(() => {
    if (wrapper) {
      if (!$showContentOverlay) {
        showBackupToastIfNeeded();
      } else if (hidden) {
        hidden = false;
        switchPanes();
        moveFocus();
        resetBackupToastState();
      }
    }
  });
</script>

{#snippet firstPane()}
  {#if $editorFirstPane}
    {@const { locale, mode } = $editorFirstPane}
    <div class="pane-wrapper">
      <Group
        class="pane"
        aria-label={$_(mode === 'edit' ? 'edit_x_locale' : 'preview_x_locale', {
          values: { locale: getLocaleLabel(locale) ?? locale },
        })}
        data-locale={locale}
        data-mode={mode}
      >
        <PaneHeader id="first-pane-header" thisPane={editorFirstPane} thatPane={editorSecondPane} />
        <PaneBody
          id="first-pane-body"
          thisPane={editorFirstPane}
          bind:thisPaneContentArea={firstPaneContentArea}
          bind:thatPaneContentArea={secondPaneContentArea}
        />
      </Group>
    </div>
  {/if}
{/snippet}

{#snippet secondPane()}
  {#if $editorSecondPane}
    {@const { locale, mode } = $editorSecondPane}
    <div class="pane-wrapper">
      <Group
        aria-label={$_(mode === 'edit' ? 'edit_x_locale' : 'preview_x_locale', {
          values: { locale: getLocaleLabel(locale) ?? locale },
        })}
        data-locale={locale}
        data-mode={mode}
      >
        <PaneHeader
          id="second-pane-header"
          thisPane={editorSecondPane}
          thatPane={editorFirstPane}
        />
        <PaneBody
          id="second-pane-body"
          thisPane={editorSecondPane}
          bind:thisPaneContentArea={secondPaneContentArea}
          bind:thatPaneContentArea={firstPaneContentArea}
        />
      </Group>
    </div>
  {/if}
{/snippet}

<div
  role="group"
  class="wrapper content-editor"
  aria-label={$_('content_editor')}
  bind:this={wrapper}
>
  {#key $entryDraft?.id}
    <Toolbar disabled={isNew && createDisabled} />
    {#if $entryDraft === null}
      <!-- Hide the content after saving a draft -->
    {:else if notFound || (isNew && createDisabled)}
      <EmptyState>
        <div role="none">
          {#if notFound}
            {$_('entry_not_found')}
          {:else if !canCreate}
            {$_('creating_entries_disabled_by_admin')}
          {:else}
            {$_('creating_entries_disabled_by_limit', { values: { limit } })}
          {/if}
        </div>
        <div role="none">
          <Button
            variant="primary"
            onclick={() => {
              goto(`/collection/${collection?.name}`, {
                replaceState: true,
                transitionType: 'backwards',
              });
            }}
          >
            {$_('back_to_collection')}
          </Button>
        </div>
      </EmptyState>
    {:else}
      {#key collection}
        {#if $editorFirstPane && $editorSecondPane && firstPaneSize && secondPaneSize}
          <ResizablePaneGroup
            onResize={({ sizes }) => {
              if ($editorFirstPane && $editorSecondPane) {
                [$editorFirstPane.width, $editorSecondPane.width] = sizes;
              }
            }}
          >
            <ResizablePane defaultSize={firstPaneSize} minSize={minPaneSize}>
              {@render firstPane()}
            </ResizablePane>
            <ResizableHandle />
            <ResizablePane defaultSize={secondPaneSize} minSize={minPaneSize}>
              {@render secondPane()}
            </ResizablePane>
          </ResizablePaneGroup>
        {:else if $editorFirstPane}
          {@render firstPane()}
        {:else if $editorSecondPane}
          {@render secondPane()}
        {/if}
      {/key}
    {/if}
  {/key}
</div>

<BackupFeedback />

<Toast bind:show={$showDuplicateToast}>
  <Alert status="success">
    {$_('entry_duplicated')}
  </Alert>
</Toast>

<style lang="scss">
  .wrapper {
    position: fixed;
    inset: 0;
    z-index: 100;
    display: flex;
    flex-direction: column;
    background-color: var(--sui-secondary-background-color);

    :global {
      .sui.resizable-pane-group {
        background-color: var(--sui-secondary-background-color); // same as toolbar
      }

      .sui.resizable-pane {
        background-color: var(--sui-primary-background-color);
      }
    }
  }

  .pane-wrapper {
    display: contents;

    :global {
      & > .group {
        height: 100%;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
    }
  }
</style>
